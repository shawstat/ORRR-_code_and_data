# -*- coding: utf-8 -*-
"""
Created on Sun Sep 25 16:10:14 2022

@author: shaw
"""

"""
In this example we show how to implement the algorithm at different batch sizes and compare the results. 
If you want to compare other parameters, the program framework is the same. 
Just fix the other parameters and let the target parameters vary.
"""


from functions_simu import *


'Set the basic parameters'
p = 200 #The dimension of response y
q = 200 #The dimension of covariate x
r =30 #The rank of coefficient matrix
sigma  = 0.1 #The variance of sub-gaussian error
rho = 0.6  #The parameter in SigX
ini_size = 250 #The number of data we use for the initialization step
test_size = 100 #The number of new data we used for prediction
mu=5  #The scale of the intercept term
T = 20000    #The maximum iteration numbers
m_list = [1,2,5,10,20] #The different choise of batch size


'Generate the true parameters'
np.random.seed(10)
A0 = np.random.randn(p,r)
B0 = np.random.randn(q,r)
mu0 = mu*np.ones(p)


'Parameter initialization'
A1,B1,mu1 = para_initi(A0,B0,mu0,p,q,r,rho,sigma,ini_size)

'The calculation of condition numbers'
Sig = np.zeros([q,q])
for i in range(q):
    for j in range(q):
        Sig[i,j] = rho**(np.abs(i-j))
_,s1,_ = np.linalg.svd(Sig)
ksig = s1[0]/s1[-1] 
_,s2,_ = np.linalg.svd(np.dot(A0,B0.T))
kc = s2[0]/s2[r-1]

'Estimation by ORRR and the calculation of error'
err_AB_list = list()
err_mu_list = list()
err_pre_list = list()
err_mee_list = list()
T_list = np.zeros(5)
for k in range(len(m_list)):
    m = m_list[k]
    T_list[k]=T
    N = T*m
    t0  = time()
    'The setting of step sizes'
    alpha = 0.2*20*s1[-1]*s2[r-1]
    aa=3
    eta_c = aa/(alpha*(np.arange(1,N+1)+np.ones(N)*(ksig*kc)**2))
    eta_mu = 1/(20*(np.arange(1,N+1)))
    
    'The generation of data'
    Y,X = data_gen_RRR(A0,B0,mu0,p,q,N,r,rho,sigma,myseed =101)
    Y_test,X_test = data_gen_RRR(A0,B0,mu0,p,q,100,r,rho,sigma,myseed=21)
    
    est_A,est_B,est_mu = SGD_RRR(Y,X,A1,B1,mu1,m,eta_c,eta_mu,T)  #The estimation generated by ORRR algo
    err_ab,err_mu = error_para(est_A,est_B,est_mu,A0,B0,mu0)
    err_pre = error_pred(est_A,est_B,est_mu,Y_test,X_test)
    err_mee = error_regret(est_A,est_B,est_mu,Y,X,m,A0,B0,mu0)
    print('The estimation of batch size %d finishes in %f seconds'%(m,time()-t0))
    err_AB_list.append(err_ab)
    err_mu_list.append(err_mu)
    err_pre_list.append(err_pre)
    err_mee_list.append(err_mee)
    

'Estimation by OSAA (Yang et al. 2020). It is only avaliavle in the small case (e.g. p=q=20)'
# err_AB_list = list()
# err_mu_list = list()
# err_pre_list = list()
# T_list = np.zeros(5)
# for k in range(len(m_list)):
#     m = m_list[k]
#     T = int(N/m)
#     est_A,est_B,est_mu = OSMM(Y,X,A1,B1,mu1,m,eta_c,eta_mu,T)
#     err_ab,err_mu = error_para(est_A,est,est_mu,A0,B0,mu0)
#     err_pre = error_pred(est_A,est_B,est_mu,Y_test,X_test)
#     err_AB_list.append(err_ab)
#     err_mu_list.append(err_mu)

'Plot the estimation error'
l=0         #The start point of the iteration numbers
plt.figure()  #The error of coefficient parameter
plt.xlabel('iteration times')
plt.ylabel('Mean Squared error of C*')
plt.plot(np.arange(l,int(T_list[0])),err_AB_list[0][l:],label='m=1')
plt.plot(np.arange(l,int(T_list[1])),err_AB_list[1][l:],label='m=2')
plt.plot(np.arange(l,int(T_list[2])),err_AB_list[2][l:],label='m=5')
plt.plot(np.arange(l,int(T_list[3])),err_AB_list[3][l:],label='m=10')
plt.plot(np.arange(l,int(T_list[4])),err_AB_list[4][l:],label='m=20')
plt.legend()
#plt.savefig("mse_C_diff_m.pdf")

plt.figure()  #The error of coefficient parameter
plt.xlabel('iteration times')
plt.ylabel('Mean Squared error of Î¼*')
plt.plot(np.arange(l,int(T_list[0])),err_mu_list[0][l:],label='m=1')
plt.plot(np.arange(l,int(T_list[1])),err_mu_list[1][l:],label='m=2')
plt.plot(np.arange(l,int(T_list[2])),err_mu_list[2][l:],label='m=5')
plt.plot(np.arange(l,int(T_list[3])),err_mu_list[3][l:],label='m=10')
plt.plot(np.arange(l,int(T_list[4])),err_mu_list[4][l:],label='m=20')
plt.legend()
#plt.savefig("mse_mu_diff_m.pdf")

plt.figure()  #The error of coefficient parameter
plt.xlabel('iteration times')
plt.ylabel('The mean prediction error in the test set')
plt.plot(np.arange(l,int(T_list[0])),err_pre_list[0][l:],label='m=1')
plt.plot(np.arange(l,int(T_list[1])),err_pre_list[1][l:],label='m=2')
plt.plot(np.arange(l,int(T_list[2])),err_pre_list[2][l:],label='m=5')
plt.plot(np.arange(l,int(T_list[3])),err_pre_list[3][l:],label='m=10')
plt.plot(np.arange(l,int(T_list[4])),err_pre_list[4][l:],label='m=20')
plt.legend()
#plt.savefig("pre_err_diff_m.pdf")

plt.figure()  #The error of coefficient parameter
plt.xlabel('iteration times')
plt.ylabel('The mean estimation error')
plt.plot(np.arange(l,int(T_list[0])),err_mee_list[0][l:],label='m=1')
plt.plot(np.arange(l,int(T_list[1])),err_mee_list[1][l:],label='m=2')
plt.plot(np.arange(l,int(T_list[2])),err_mee_list[2][l:],label='m=5')
plt.plot(np.arange(l,int(T_list[3])),err_mee_list[3][l:],label='m=10')
plt.plot(np.arange(l,int(T_list[4])),err_mee_list[4][l:],label='m=20')
plt.legend()
#plt.savefig("mee_err_diff_m.pdf")
    






